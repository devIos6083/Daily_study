# 📅 Day 1 — 클래스(Class) & 모듈(Module)

**날짜 / 日付(ひづけ):** 2025.02.19  
**학습 시간 / 学習時間(がくしゅうじかん):** 2시간 / 2時間(じかん)  
**한 줄 목표:** 클래스와 모듈의 차이를 이해하고, Ruby 객체 지향의 기초를 잡는다.  
**一言目標(ひとこともくひょう):** クラスとモジュールの違(ちが)いを理解(りかい)して、Rubyの基礎(きそ)を固(かた)める。

---

## 목차 / 目次(もくじ)

1. [클래스 (Class)](#1-클래스-class)
2. [인스턴스 변수 vs 로컬 변수](#2-인스턴스-변수-vs-로컬-변수)
3. [모듈 (Module)](#3-모듈-module)
4. [Ruby다운 습관](#4-ruby다운-습관)
5. [키워드 정리](#5-키워드-정리)

---

## 1. 클래스 (Class)

클래스는 데이터(변수)와 기능(메서드)을 하나로 묶는 **설계도**입니다.  
`User.new("강씨", 26)` 으로 설계도를 바탕으로 실제 객체를 만들고, 이 객체를 **인스턴스**라고 부릅니다.

クラスはデータ(変数(へんすう))と機能(きのう)(メソッド)をひとつにまとめた**設計図(せっけいず)**です。  
`User.new("강씨", 26)` で設計図(せっけいず)をもとに実際(じっさい)のオブジェクトを作(つく)り、これを**インスタンス**と呼(よ)びます。

```ruby
class User
  # attr_accessor: @name, @age의 getter/setter를 자동으로 만들어줌
  # 없으면 외부에서 user.name 으로 읽거나 쓰는 게 불가능
  attr_accessor :name, :age

  # initialize: new() 호출 시 자동으로 실행되는 메서드
  # 반드시 이름이 initialize 여야 함 (initializer ❌)
  def initialize(name, age)
    @name = name   # @변수: 인스턴스 변수. 이 객체 안 어디서든 사용 가능
    @age  = age
  end

  def introduce
    "안녕하세요, #{@name}이고 #{@age}살입니다"
  end
end

user = User.new("강씨", 26)
puts user.introduce   # → 안녕하세요, 강씨이고 26살입니다
puts user.name        # → 강씨      (attr_accessor 덕분에 읽기 가능)
user.name = "Charles" # attr_accessor 덕분에 쓰기도 가능
puts user.name        # → Charles
```

---

## 2. 인스턴스 변수 vs 로컬 변수

`@변수`는 메서드가 끝나도 인스턴스 안에 살아남습니다.  
로컬 변수는 선언된 메서드 안에서만 존재하고, 밖에서 접근하면 에러가 납니다.

`@変数(へんすう)`はメソッドが終(お)わってもインスタンスの中(なか)に残(のこ)ります。  
ローカル変数(へんすう)は宣言(せんげん)したメソッドの中(なか)だけで存在(そんざい)し、外(そと)からアクセスするとエラーになります。

```ruby
class Example
  def set_value
    @saved = "나는 살아남는다"  # @변수: 메서드가 끝나도 인스턴스에 저장됨
    temp   = "나는 사라진다"    # 로컬 변수: 이 메서드 안에서만 존재
  end

  def get_value
    puts @saved   # ✅ 다른 메서드에서도 접근 가능
    puts temp     # ❌ 에러! 로컬 변수는 메서드 밖에서 접근 불가
  end
end
```

---

## 3. 모듈 (Module)

모듈은 메서드 묶음입니다. 클래스가 아니라서 `new()`로 객체를 만들 수 없습니다.  
`include`로 클래스에 장착하면, 그 클래스의 메서드처럼 사용할 수 있습니다.  
하나의 모듈을 수백 개의 클래스에 재사용할 수 있다는 것이 핵심 장점입니다.

モジュールはメソッドのまとまりです。クラスではないので`new()`でオブジェクトを作(つく)れません。  
`include`でクラスに追加(ついか)すると、そのクラスのメソッドのように使(つか)えます。  
ひとつのモジュールを何百(なんびゃく)ものクラスで再利用(さいりよう)できることが大(おお)きな強(つよ)みです。

> **비유 / たとえ:**  
> 클래스 = 사람 / クラス = 人(ひと)  
> 모듈 = 자격증 (수영, 운전, 요리...) / モジュール = 資格(しかく)（水泳(すいえい)、運転(うんてん)、料理(りょうり)…）  
> 자격증 하나를 여러 사람이 취득(include)해서 그 기능을 쓸 수 있다.  
> 一(ひと)つの資格(しかく)を多(おお)くの人(ひと)が取得(しゅとく)して使(つか)えるのと同(おな)じ。

```ruby
module Greetable
  def greet
    # @name은 이 모듈을 include한 클래스의 인스턴스 변수를 가리킴
    # include되는 순간 같은 인스턴스 안으로 합쳐지기 때문에 접근 가능
    "#{@name}가 인사합니다!"
  end
end

module Farewell
  def bye
    "#{@name}가 작별 인사합니다!"
  end
end

class User
  include Greetable  # 모듈 장착. 여러 개 include 가능
  include Farewell

  def initialize(name)
    @name = name
  end
end

user = User.new("강씨")
puts user.greet   # → 강씨가 인사합니다!
puts user.bye     # → 강씨가 작별 인사합니다!
```

---

## 4. Ruby다운 습관

오늘 배운 Ruby 스타일의 코드 작성 방법입니다.  
今日(きょう)学(まな)んだ、Rubyらしいコードの書(か)き方(かた)です。

```ruby
# ✅ ?로 끝나는 메서드는 true/false를 반환하는 관례
# ✅ 비교식 자체가 이미 true/false이므로 if/else 불필요

# ❌ 장황한 방식
def long_book?
  if @page_count >= 300
    true
  else
    false
  end
end

# ✅ Ruby다운 방식
def long_book?
  @page_count >= 300  # 300 이상(>=) vs 300 초과(>) 주의!
end


# ✅ 마지막 줄의 값이 자동으로 반환됨 → return 생략 가능
def discounted_price(original_price)
  if @page_count >= 300
    original_price * 0.8   # 20% 할인
  else
    original_price * 0.9   # 10% 할인
  end
end
```

---

## 5. 키워드 정리

한눈에 보는 오늘의 키워드입니다.  
今日(きょう)のキーワードを一目(ひとめ)でまとめます。

| 키워드 | 설명 |
|:---|:---|
| `class 이름` | 클래스 정의 시작 |
| `end` | 클래스 / 메서드 / 모듈 종료 |
| `def initialize` | `new()` 호출 시 자동 실행 (생성자) |
| `@변수` | 인스턴스 변수. 같은 객체 안 어디서든 접근 가능 |
| `attr_accessor :x` | `@x`의 읽기(getter) + 쓰기(setter) 자동 생성 |
| `attr_reader :x` | 읽기만 가능 |
| `attr_writer :x` | 쓰기만 가능 |
| `module 이름` | 모듈 정의 |
| `include 모듈이름` | 클래스에 모듈 장착 |
| `클래스.new(값)` | 인스턴스(객체) 생성 |

---

## ✍️ 오늘의 느낀 점 / 今日(きょう)の感想(かんそう)

오늘 처음엔 `initializer`로 잘못 썼다가 에러를 만났습니다.  
Ruby는 예약된 메서드 이름을 정확히 써야 한다는 것을 몸으로 배웠습니다.  
모듈이 `include`되는 순간 인스턴스 안으로 합쳐진다는 개념이 특히 인상적이었습니다.

最初(さいしょ)は`initializer`と書(か)いてしまってエラーになりました。  
Rubyでは決(き)まったメソッド名(めい)を正確(せいかく)に書(か)く必要(ひつよう)があると、実際(じっさい)に体験(たいけん)して学(まな)びました。  
モジュールが`include`された瞬間(しゅんかん)、インスタンスの中(なか)に合(あ)わさるという考(かんが)え方(かた)がとても印象的(いんしょうてき)でした。

---

[← 목차로 돌아가기 / 目次(もくじ)に戻(もど)る](../README.md)
